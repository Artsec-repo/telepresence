// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/telepresenceio/telepresence/rpc/v2/daemon (interfaces: DaemonClient)

// Package mock_trafficmgr is a generated GoMock package.
package mock_trafficmgr

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	common "github.com/telepresenceio/telepresence/rpc/v2/common"
	daemon "github.com/telepresenceio/telepresence/rpc/v2/daemon"
	manager "github.com/telepresenceio/telepresence/rpc/v2/manager"
	grpc "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// MockDaemonClient is a mock of DaemonClient interface.
type MockDaemonClient struct {
	ctrl     *gomock.Controller
	recorder *MockDaemonClientMockRecorder
}

// MockDaemonClientMockRecorder is the mock recorder for MockDaemonClient.
type MockDaemonClientMockRecorder struct {
	mock *MockDaemonClient
}

// NewMockDaemonClient creates a new mock instance.
func NewMockDaemonClient(ctrl *gomock.Controller) *MockDaemonClient {
	mock := &MockDaemonClient{ctrl: ctrl}
	mock.recorder = &MockDaemonClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDaemonClient) EXPECT() *MockDaemonClientMockRecorder {
	return m.recorder
}

// Connect mocks base method.
func (m *MockDaemonClient) Connect(arg0 context.Context, arg1 *daemon.OutboundInfo, arg2 ...grpc.CallOption) (*daemon.DaemonStatus, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Connect", varargs...)
	ret0, _ := ret[0].(*daemon.DaemonStatus)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Connect indicates an expected call of Connect.
func (mr *MockDaemonClientMockRecorder) Connect(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockDaemonClient)(nil).Connect), varargs...)
}

// Disconnect mocks base method.
func (m *MockDaemonClient) Disconnect(arg0 context.Context, arg1 *emptypb.Empty, arg2 ...grpc.CallOption) (*emptypb.Empty, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Disconnect", varargs...)
	ret0, _ := ret[0].(*emptypb.Empty)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Disconnect indicates an expected call of Disconnect.
func (mr *MockDaemonClientMockRecorder) Disconnect(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Disconnect", reflect.TypeOf((*MockDaemonClient)(nil).Disconnect), varargs...)
}

// GetNetworkConfig mocks base method.
func (m *MockDaemonClient) GetNetworkConfig(arg0 context.Context, arg1 *emptypb.Empty, arg2 ...grpc.CallOption) (*daemon.NetworkConfig, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetNetworkConfig", varargs...)
	ret0, _ := ret[0].(*daemon.NetworkConfig)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNetworkConfig indicates an expected call of GetNetworkConfig.
func (mr *MockDaemonClientMockRecorder) GetNetworkConfig(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNetworkConfig", reflect.TypeOf((*MockDaemonClient)(nil).GetNetworkConfig), varargs...)
}

// Quit mocks base method.
func (m *MockDaemonClient) Quit(arg0 context.Context, arg1 *emptypb.Empty, arg2 ...grpc.CallOption) (*emptypb.Empty, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Quit", varargs...)
	ret0, _ := ret[0].(*emptypb.Empty)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Quit indicates an expected call of Quit.
func (mr *MockDaemonClientMockRecorder) Quit(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Quit", reflect.TypeOf((*MockDaemonClient)(nil).Quit), varargs...)
}

// SetDnsSearchPath mocks base method.
func (m *MockDaemonClient) SetDnsSearchPath(arg0 context.Context, arg1 *daemon.Paths, arg2 ...grpc.CallOption) (*emptypb.Empty, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetDnsSearchPath", varargs...)
	ret0, _ := ret[0].(*emptypb.Empty)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetDnsSearchPath indicates an expected call of SetDnsSearchPath.
func (mr *MockDaemonClientMockRecorder) SetDnsSearchPath(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDnsSearchPath", reflect.TypeOf((*MockDaemonClient)(nil).SetDnsSearchPath), varargs...)
}

// SetLogLevel mocks base method.
func (m *MockDaemonClient) SetLogLevel(arg0 context.Context, arg1 *manager.LogLevelRequest, arg2 ...grpc.CallOption) (*emptypb.Empty, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetLogLevel", varargs...)
	ret0, _ := ret[0].(*emptypb.Empty)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetLogLevel indicates an expected call of SetLogLevel.
func (mr *MockDaemonClientMockRecorder) SetLogLevel(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLogLevel", reflect.TypeOf((*MockDaemonClient)(nil).SetLogLevel), varargs...)
}

// Status mocks base method.
func (m *MockDaemonClient) Status(arg0 context.Context, arg1 *emptypb.Empty, arg2 ...grpc.CallOption) (*daemon.DaemonStatus, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Status", varargs...)
	ret0, _ := ret[0].(*daemon.DaemonStatus)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Status indicates an expected call of Status.
func (mr *MockDaemonClientMockRecorder) Status(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockDaemonClient)(nil).Status), varargs...)
}

// Version mocks base method.
func (m *MockDaemonClient) Version(arg0 context.Context, arg1 *emptypb.Empty, arg2 ...grpc.CallOption) (*common.VersionInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Version", varargs...)
	ret0, _ := ret[0].(*common.VersionInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Version indicates an expected call of Version.
func (mr *MockDaemonClientMockRecorder) Version(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Version", reflect.TypeOf((*MockDaemonClient)(nil).Version), varargs...)
}

// WaitForNetwork mocks base method.
func (m *MockDaemonClient) WaitForNetwork(arg0 context.Context, arg1 *emptypb.Empty, arg2 ...grpc.CallOption) (*emptypb.Empty, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WaitForNetwork", varargs...)
	ret0, _ := ret[0].(*emptypb.Empty)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WaitForNetwork indicates an expected call of WaitForNetwork.
func (mr *MockDaemonClientMockRecorder) WaitForNetwork(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForNetwork", reflect.TypeOf((*MockDaemonClient)(nil).WaitForNetwork), varargs...)
}
